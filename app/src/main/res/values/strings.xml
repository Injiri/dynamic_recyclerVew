<resources>
    <string name="app_name">Generic c++</string>
    <string name="navigation_drawer_open">Open navigation drawer</string>
    <string name="navigation_drawer_close">Close navigation drawer</string>
    <string name="nav_header_title">Android Studio</string>
    <string name="nav_header_subtitle">android.studio@android.com</string>
    <string name="nav_header_desc">Navigation header</string>
    <string name="action_settings">Settings</string>

    <string name="menu_home">Home</string>
    <string name="menu_exam">Exam answers</string>
    <string name="menu_application">Applications of Generic c++</string>
    <string name="menu_about">About</string>
    <string name="menu_help">Help and feedback</string>
    <string name="menu_terms">Terms and conditions</string>
    <string name="menu_cat">Cat answers</string>
    <string name="menu_assignment">Assignment</string>

    <string name="classtemplates_chapter">
        <b>Class Templates</b> \n
Introduction "\n \n"
Class templates enable you to conveniently specify a variety of related classes – referred to as class template
specializations. Programming with templates is also known as generic programming. \n \n
1.1 \n \n
Class Templates \n \n
Class templates encourage software re-usability by enabling a variety of type-specific class template specilaiza-
tions to instantiated from a single class template. \n \n
All class templates begin with a keyword template followed by a list of template parameters enclosed
in angle brackets. Each template parameter that represent a type must be preceded by either
typename or class, though typename is preferred to avoid ambiguity. Just like other parameters, the
names of a parameter must be unique inside template definition.
Type parameter becomes associated with a specific type when you create an object using the class template–
at this point, the compiler generates a copy of the class template, in which all the occurrences of the type
parameter are replaced with specified type. \n \n
1.2
Stack/Queue Class Template-How to represent data \n \n
A stack can use various containers to store its elements. A stack requires insertions and deletions only at
its top. Therefore, a vector or a deque could be used to store a stack elements. A vector supports faster
insertions and deletions at the back. A deque supports fast insertions and deletions and its front and its
back. A deque is the default representation for the Standard Library’s stack adapter because a deque grows
more deficiently than a vector. \n \n
A vector is maintained as a contiguous block of memory – when that block is full and a new element
is added, the vector allocates a larger contiguous block of memory and copies the old elements into the new
block. A deque on other hand, is typically implemented as a list of fixed size built-in arrays – new fixed-size
built-in arrays are added as necessary and none of the existing elements are copied when new items are
added to the front or back. For this reason, a deque is most appropriate underlying container to implement
a stack or a queue. \n \n
    </string>

</resources>
